/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef query_TYPES_H
#define query_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace com { namespace mediav { namespace query {

struct PeerStatus {
  enum type {
    P_READY = 0,
    P_STOP = 1,
    P_PAUSE = 2,
    P_DEL = 3
  };
};

extern const std::map<int, const char*> _PeerStatus_VALUES_TO_NAMES;

typedef class QuerySession SearchLabels;

typedef class TokenInfo SearchLabel;

class QueryInfo;

class UrlInfo;

class ProductInfo;

class SiteProductInfo;

class UserQuery;

class TokenInfo;

class QuerySession;

class UserInfo;

class KeywordLabelInfo;

class KeywordLabelVersionInfo;

class KeywordLabelData;

class ResponseVector;

class KeyWords;

class Response;

class KeywordCreative;

class KeywordCreativeFeature;

class KeywordCreativeResponse;

typedef struct _QueryInfo__isset {
  _QueryInfo__isset() : timestamp(false), source(false) {}
  bool timestamp :1;
  bool source :1;
} _QueryInfo__isset;

class QueryInfo {
 public:

  static const char* ascii_fingerprint; // = "D97FA59F95051FA1EC8B096DE2508323";
  static const uint8_t binary_fingerprint[16]; // = {0xD9,0x7F,0xA5,0x9F,0x95,0x05,0x1F,0xA1,0xEC,0x8B,0x09,0x6D,0xE2,0x50,0x83,0x23};

  QueryInfo(const QueryInfo&);
  QueryInfo& operator=(const QueryInfo&);
  QueryInfo() : timestamp(0), source(0) {
  }

  virtual ~QueryInfo() throw();
  std::vector<std::string>  tokens;
  int64_t timestamp;
  int32_t source;

  _QueryInfo__isset __isset;

  void __set_tokens(const std::vector<std::string> & val);

  void __set_timestamp(const int64_t val);

  void __set_source(const int32_t val);

  bool operator == (const QueryInfo & rhs) const
  {
    if (!(tokens == rhs.tokens))
      return false;
    if (__isset.timestamp != rhs.__isset.timestamp)
      return false;
    else if (__isset.timestamp && !(timestamp == rhs.timestamp))
      return false;
    if (__isset.source != rhs.__isset.source)
      return false;
    else if (__isset.source && !(source == rhs.source))
      return false;
    return true;
  }
  bool operator != (const QueryInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const QueryInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const QueryInfo& obj);
};

void swap(QueryInfo &a, QueryInfo &b);

typedef struct _UrlInfo__isset {
  _UrlInfo__isset() : timestamp(false) {}
  bool timestamp :1;
} _UrlInfo__isset;

class UrlInfo {
 public:

  static const char* ascii_fingerprint; // = "E17E126D15049701494262EE3246F603";
  static const uint8_t binary_fingerprint[16]; // = {0xE1,0x7E,0x12,0x6D,0x15,0x04,0x97,0x01,0x49,0x42,0x62,0xEE,0x32,0x46,0xF6,0x03};

  UrlInfo(const UrlInfo&);
  UrlInfo& operator=(const UrlInfo&);
  UrlInfo() : url(), timestamp(0) {
  }

  virtual ~UrlInfo() throw();
  std::string url;
  int64_t timestamp;

  _UrlInfo__isset __isset;

  void __set_url(const std::string& val);

  void __set_timestamp(const int64_t val);

  bool operator == (const UrlInfo & rhs) const
  {
    if (!(url == rhs.url))
      return false;
    if (__isset.timestamp != rhs.__isset.timestamp)
      return false;
    else if (__isset.timestamp && !(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const UrlInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UrlInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const UrlInfo& obj);
};

void swap(UrlInfo &a, UrlInfo &b);

typedef struct _ProductInfo__isset {
  _ProductInfo__isset() : timestamp(false) {}
  bool timestamp :1;
} _ProductInfo__isset;

class ProductInfo {
 public:

  static const char* ascii_fingerprint; // = "E17E126D15049701494262EE3246F603";
  static const uint8_t binary_fingerprint[16]; // = {0xE1,0x7E,0x12,0x6D,0x15,0x04,0x97,0x01,0x49,0x42,0x62,0xEE,0x32,0x46,0xF6,0x03};

  ProductInfo(const ProductInfo&);
  ProductInfo& operator=(const ProductInfo&);
  ProductInfo() : id(), timestamp(0) {
  }

  virtual ~ProductInfo() throw();
  std::string id;
  int64_t timestamp;

  _ProductInfo__isset __isset;

  void __set_id(const std::string& val);

  void __set_timestamp(const int64_t val);

  bool operator == (const ProductInfo & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (__isset.timestamp != rhs.__isset.timestamp)
      return false;
    else if (__isset.timestamp && !(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const ProductInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ProductInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ProductInfo& obj);
};

void swap(ProductInfo &a, ProductInfo &b);

typedef struct _SiteProductInfo__isset {
  _SiteProductInfo__isset() : src(false) {}
  bool src :1;
} _SiteProductInfo__isset;

class SiteProductInfo {
 public:

  static const char* ascii_fingerprint; // = "5EEEC779DFDAE0CCCE7901771348BFB8";
  static const uint8_t binary_fingerprint[16]; // = {0x5E,0xEE,0xC7,0x79,0xDF,0xDA,0xE0,0xCC,0xCE,0x79,0x01,0x77,0x13,0x48,0xBF,0xB8};

  SiteProductInfo(const SiteProductInfo&);
  SiteProductInfo& operator=(const SiteProductInfo&);
  SiteProductInfo() : src() {
  }

  virtual ~SiteProductInfo() throw();
  std::vector<ProductInfo>  productInfos;
  std::string src;

  _SiteProductInfo__isset __isset;

  void __set_productInfos(const std::vector<ProductInfo> & val);

  void __set_src(const std::string& val);

  bool operator == (const SiteProductInfo & rhs) const
  {
    if (!(productInfos == rhs.productInfos))
      return false;
    if (__isset.src != rhs.__isset.src)
      return false;
    else if (__isset.src && !(src == rhs.src))
      return false;
    return true;
  }
  bool operator != (const SiteProductInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SiteProductInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const SiteProductInfo& obj);
};

void swap(SiteProductInfo &a, SiteProductInfo &b);

typedef struct _UserQuery__isset {
  _UserQuery__isset() : uid(false), lastUpdateTime(false), urls(false), products(false), latestDateData(false), firstMvidData(false), mid(false) {}
  bool uid :1;
  bool lastUpdateTime :1;
  bool urls :1;
  bool products :1;
  bool latestDateData :1;
  bool firstMvidData :1;
  bool mid :1;
} _UserQuery__isset;

class UserQuery {
 public:

  static const char* ascii_fingerprint; // = "765DDE17DDF32975722F3601D832E9A6";
  static const uint8_t binary_fingerprint[16]; // = {0x76,0x5D,0xDE,0x17,0xDD,0xF3,0x29,0x75,0x72,0x2F,0x36,0x01,0xD8,0x32,0xE9,0xA6};

  UserQuery(const UserQuery&);
  UserQuery& operator=(const UserQuery&);
  UserQuery() : uid(), lastUpdateTime(0), latestDateData(0), firstMvidData(0), mid() {
  }

  virtual ~UserQuery() throw();
  std::vector<QueryInfo>  queries;
  std::string uid;
  int64_t lastUpdateTime;
  std::vector<UrlInfo>  urls;
  std::vector<SiteProductInfo>  products;
  bool latestDateData;
  bool firstMvidData;
  std::string mid;

  _UserQuery__isset __isset;

  void __set_queries(const std::vector<QueryInfo> & val);

  void __set_uid(const std::string& val);

  void __set_lastUpdateTime(const int64_t val);

  void __set_urls(const std::vector<UrlInfo> & val);

  void __set_products(const std::vector<SiteProductInfo> & val);

  void __set_latestDateData(const bool val);

  void __set_firstMvidData(const bool val);

  void __set_mid(const std::string& val);

  bool operator == (const UserQuery & rhs) const
  {
    if (!(queries == rhs.queries))
      return false;
    if (__isset.uid != rhs.__isset.uid)
      return false;
    else if (__isset.uid && !(uid == rhs.uid))
      return false;
    if (__isset.lastUpdateTime != rhs.__isset.lastUpdateTime)
      return false;
    else if (__isset.lastUpdateTime && !(lastUpdateTime == rhs.lastUpdateTime))
      return false;
    if (__isset.urls != rhs.__isset.urls)
      return false;
    else if (__isset.urls && !(urls == rhs.urls))
      return false;
    if (__isset.products != rhs.__isset.products)
      return false;
    else if (__isset.products && !(products == rhs.products))
      return false;
    if (__isset.latestDateData != rhs.__isset.latestDateData)
      return false;
    else if (__isset.latestDateData && !(latestDateData == rhs.latestDateData))
      return false;
    if (__isset.firstMvidData != rhs.__isset.firstMvidData)
      return false;
    else if (__isset.firstMvidData && !(firstMvidData == rhs.firstMvidData))
      return false;
    if (__isset.mid != rhs.__isset.mid)
      return false;
    else if (__isset.mid && !(mid == rhs.mid))
      return false;
    return true;
  }
  bool operator != (const UserQuery &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserQuery & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const UserQuery& obj);
};

void swap(UserQuery &a, UserQuery &b);

typedef struct _TokenInfo__isset {
  _TokenInfo__isset() : weight(true) {}
  bool weight :1;
} _TokenInfo__isset;

class TokenInfo {
 public:

  static const char* ascii_fingerprint; // = "6E578DA8AB10EED824A75534350EBAEF";
  static const uint8_t binary_fingerprint[16]; // = {0x6E,0x57,0x8D,0xA8,0xAB,0x10,0xEE,0xD8,0x24,0xA7,0x55,0x34,0x35,0x0E,0xBA,0xEF};

  TokenInfo(const TokenInfo&);
  TokenInfo& operator=(const TokenInfo&);
  TokenInfo() : id(0), weight(1) {
  }

  virtual ~TokenInfo() throw();
  int64_t id;
  int32_t weight;

  _TokenInfo__isset __isset;

  void __set_id(const int64_t val);

  void __set_weight(const int32_t val);

  bool operator == (const TokenInfo & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (__isset.weight != rhs.__isset.weight)
      return false;
    else if (__isset.weight && !(weight == rhs.weight))
      return false;
    return true;
  }
  bool operator != (const TokenInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TokenInfo& obj);
};

void swap(TokenInfo &a, TokenInfo &b);

typedef struct _QuerySession__isset {
  _QuerySession__isset() : tokenInfos(false), score(false), sessionId(false), timestamp(false), source(false) {}
  bool tokenInfos :1;
  bool score :1;
  bool sessionId :1;
  bool timestamp :1;
  bool source :1;
} _QuerySession__isset;

class QuerySession {
 public:

  static const char* ascii_fingerprint; // = "FEA06D03C7B7A4106B656F25D081AC90";
  static const uint8_t binary_fingerprint[16]; // = {0xFE,0xA0,0x6D,0x03,0xC7,0xB7,0xA4,0x10,0x6B,0x65,0x6F,0x25,0xD0,0x81,0xAC,0x90};

  QuerySession(const QuerySession&);
  QuerySession& operator=(const QuerySession&);
  QuerySession() : score(0), sessionId(0), timestamp(0), source(0) {
  }

  virtual ~QuerySession() throw();
  std::vector<TokenInfo>  tokenInfos;
  int32_t score;
  int64_t sessionId;
  int64_t timestamp;
  int32_t source;

  _QuerySession__isset __isset;

  void __set_tokenInfos(const std::vector<TokenInfo> & val);

  void __set_score(const int32_t val);

  void __set_sessionId(const int64_t val);

  void __set_timestamp(const int64_t val);

  void __set_source(const int32_t val);

  bool operator == (const QuerySession & rhs) const
  {
    if (__isset.tokenInfos != rhs.__isset.tokenInfos)
      return false;
    else if (__isset.tokenInfos && !(tokenInfos == rhs.tokenInfos))
      return false;
    if (__isset.score != rhs.__isset.score)
      return false;
    else if (__isset.score && !(score == rhs.score))
      return false;
    if (__isset.sessionId != rhs.__isset.sessionId)
      return false;
    else if (__isset.sessionId && !(sessionId == rhs.sessionId))
      return false;
    if (__isset.timestamp != rhs.__isset.timestamp)
      return false;
    else if (__isset.timestamp && !(timestamp == rhs.timestamp))
      return false;
    if (__isset.source != rhs.__isset.source)
      return false;
    else if (__isset.source && !(source == rhs.source))
      return false;
    return true;
  }
  bool operator != (const QuerySession &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const QuerySession & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const QuerySession& obj);
};

void swap(QuerySession &a, QuerySession &b);

typedef struct _UserInfo__isset {
  _UserInfo__isset() : mvid(false), lastUpdateTime(false), experimentId(false), searchLabels(false) {}
  bool mvid :1;
  bool lastUpdateTime :1;
  bool experimentId :1;
  bool searchLabels :1;
} _UserInfo__isset;

class UserInfo {
 public:

  static const char* ascii_fingerprint; // = "AA532CB1EC1C314FFF129A255FF3288C";
  static const uint8_t binary_fingerprint[16]; // = {0xAA,0x53,0x2C,0xB1,0xEC,0x1C,0x31,0x4F,0xFF,0x12,0x9A,0x25,0x5F,0xF3,0x28,0x8C};

  UserInfo(const UserInfo&);
  UserInfo& operator=(const UserInfo&);
  UserInfo() : mvid(), lastUpdateTime(0), experimentId(0) {
  }

  virtual ~UserInfo() throw();
  std::vector<QuerySession>  querySessions;
  std::string mvid;
  int64_t lastUpdateTime;
  int32_t experimentId;
  SearchLabels searchLabels;

  _UserInfo__isset __isset;

  void __set_querySessions(const std::vector<QuerySession> & val);

  void __set_mvid(const std::string& val);

  void __set_lastUpdateTime(const int64_t val);

  void __set_experimentId(const int32_t val);

  void __set_searchLabels(const SearchLabels& val);

  bool operator == (const UserInfo & rhs) const
  {
    if (!(querySessions == rhs.querySessions))
      return false;
    if (__isset.mvid != rhs.__isset.mvid)
      return false;
    else if (__isset.mvid && !(mvid == rhs.mvid))
      return false;
    if (__isset.lastUpdateTime != rhs.__isset.lastUpdateTime)
      return false;
    else if (__isset.lastUpdateTime && !(lastUpdateTime == rhs.lastUpdateTime))
      return false;
    if (__isset.experimentId != rhs.__isset.experimentId)
      return false;
    else if (__isset.experimentId && !(experimentId == rhs.experimentId))
      return false;
    if (__isset.searchLabels != rhs.__isset.searchLabels)
      return false;
    else if (__isset.searchLabels && !(searchLabels == rhs.searchLabels))
      return false;
    return true;
  }
  bool operator != (const UserInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const UserInfo& obj);
};

void swap(UserInfo &a, UserInfo &b);

typedef struct _KeywordLabelInfo__isset {
  _KeywordLabelInfo__isset() : lastUpdateTime(false), searchLabels(false) {}
  bool lastUpdateTime :1;
  bool searchLabels :1;
} _KeywordLabelInfo__isset;

class KeywordLabelInfo {
 public:

  static const char* ascii_fingerprint; // = "364E1D1B76C40346779497AD2B4335BE";
  static const uint8_t binary_fingerprint[16]; // = {0x36,0x4E,0x1D,0x1B,0x76,0xC4,0x03,0x46,0x77,0x94,0x97,0xAD,0x2B,0x43,0x35,0xBE};

  KeywordLabelInfo(const KeywordLabelInfo&);
  KeywordLabelInfo& operator=(const KeywordLabelInfo&);
  KeywordLabelInfo() : keywordId(0), solutionId(0), lastUpdateTime(0) {
  }

  virtual ~KeywordLabelInfo() throw();
  int64_t keywordId;
  int32_t solutionId;
  int64_t lastUpdateTime;
  std::vector<SearchLabel>  searchLabels;

  _KeywordLabelInfo__isset __isset;

  void __set_keywordId(const int64_t val);

  void __set_solutionId(const int32_t val);

  void __set_lastUpdateTime(const int64_t val);

  void __set_searchLabels(const std::vector<SearchLabel> & val);

  bool operator == (const KeywordLabelInfo & rhs) const
  {
    if (!(keywordId == rhs.keywordId))
      return false;
    if (!(solutionId == rhs.solutionId))
      return false;
    if (__isset.lastUpdateTime != rhs.__isset.lastUpdateTime)
      return false;
    else if (__isset.lastUpdateTime && !(lastUpdateTime == rhs.lastUpdateTime))
      return false;
    if (__isset.searchLabels != rhs.__isset.searchLabels)
      return false;
    else if (__isset.searchLabels && !(searchLabels == rhs.searchLabels))
      return false;
    return true;
  }
  bool operator != (const KeywordLabelInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const KeywordLabelInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const KeywordLabelInfo& obj);
};

void swap(KeywordLabelInfo &a, KeywordLabelInfo &b);

typedef struct _KeywordLabelVersionInfo__isset {
  _KeywordLabelVersionInfo__isset() : maxId(false) {}
  bool maxId :1;
} _KeywordLabelVersionInfo__isset;

class KeywordLabelVersionInfo {
 public:

  static const char* ascii_fingerprint; // = "01CA52D1ADEB91222A213253B3603B52";
  static const uint8_t binary_fingerprint[16]; // = {0x01,0xCA,0x52,0xD1,0xAD,0xEB,0x91,0x22,0x2A,0x21,0x32,0x53,0xB3,0x60,0x3B,0x52};

  KeywordLabelVersionInfo(const KeywordLabelVersionInfo&);
  KeywordLabelVersionInfo& operator=(const KeywordLabelVersionInfo&);
  KeywordLabelVersionInfo() : version(0), timestamp(0), maxId(0) {
  }

  virtual ~KeywordLabelVersionInfo() throw();
  int32_t version;
  int64_t timestamp;
  int64_t maxId;

  _KeywordLabelVersionInfo__isset __isset;

  void __set_version(const int32_t val);

  void __set_timestamp(const int64_t val);

  void __set_maxId(const int64_t val);

  bool operator == (const KeywordLabelVersionInfo & rhs) const
  {
    if (!(version == rhs.version))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (__isset.maxId != rhs.__isset.maxId)
      return false;
    else if (__isset.maxId && !(maxId == rhs.maxId))
      return false;
    return true;
  }
  bool operator != (const KeywordLabelVersionInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const KeywordLabelVersionInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const KeywordLabelVersionInfo& obj);
};

void swap(KeywordLabelVersionInfo &a, KeywordLabelVersionInfo &b);


class KeywordLabelData {
 public:

  static const char* ascii_fingerprint; // = "990061C893714DBCC112E415380E6830";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x00,0x61,0xC8,0x93,0x71,0x4D,0xBC,0xC1,0x12,0xE4,0x15,0x38,0x0E,0x68,0x30};

  KeywordLabelData(const KeywordLabelData&);
  KeywordLabelData& operator=(const KeywordLabelData&);
  KeywordLabelData() {
  }

  virtual ~KeywordLabelData() throw();
  std::map<int64_t, KeywordLabelInfo>  keywordLabelData;

  void __set_keywordLabelData(const std::map<int64_t, KeywordLabelInfo> & val);

  bool operator == (const KeywordLabelData & rhs) const
  {
    if (!(keywordLabelData == rhs.keywordLabelData))
      return false;
    return true;
  }
  bool operator != (const KeywordLabelData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const KeywordLabelData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const KeywordLabelData& obj);
};

void swap(KeywordLabelData &a, KeywordLabelData &b);

typedef struct _ResponseVector__isset {
  _ResponseVector__isset() : tokenInfos(false), ktvVersion(false) {}
  bool tokenInfos :1;
  bool ktvVersion :1;
} _ResponseVector__isset;

class ResponseVector {
 public:

  static const char* ascii_fingerprint; // = "367BA1B570DF1D1879C584A35E230BD2";
  static const uint8_t binary_fingerprint[16]; // = {0x36,0x7B,0xA1,0xB5,0x70,0xDF,0x1D,0x18,0x79,0xC5,0x84,0xA3,0x5E,0x23,0x0B,0xD2};

  ResponseVector(const ResponseVector&);
  ResponseVector& operator=(const ResponseVector&);
  ResponseVector() : ktvVersion(0) {
  }

  virtual ~ResponseVector() throw();
  std::vector<TokenInfo>  tokenInfos;
  int32_t ktvVersion;

  _ResponseVector__isset __isset;

  void __set_tokenInfos(const std::vector<TokenInfo> & val);

  void __set_ktvVersion(const int32_t val);

  bool operator == (const ResponseVector & rhs) const
  {
    if (__isset.tokenInfos != rhs.__isset.tokenInfos)
      return false;
    else if (__isset.tokenInfos && !(tokenInfos == rhs.tokenInfos))
      return false;
    if (__isset.ktvVersion != rhs.__isset.ktvVersion)
      return false;
    else if (__isset.ktvVersion && !(ktvVersion == rhs.ktvVersion))
      return false;
    return true;
  }
  bool operator != (const ResponseVector &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ResponseVector & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ResponseVector& obj);
};

void swap(ResponseVector &a, ResponseVector &b);

typedef struct _KeyWords__isset {
  _KeyWords__isset() : solutionId(false), keywordId(false) {}
  bool solutionId :1;
  bool keywordId :1;
} _KeyWords__isset;

class KeyWords {
 public:

  static const char* ascii_fingerprint; // = "F89B267CDACD3B46B828BD23E9151E7F";
  static const uint8_t binary_fingerprint[16]; // = {0xF8,0x9B,0x26,0x7C,0xDA,0xCD,0x3B,0x46,0xB8,0x28,0xBD,0x23,0xE9,0x15,0x1E,0x7F};

  KeyWords(const KeyWords&);
  KeyWords& operator=(const KeyWords&);
  KeyWords() : keywords(), solutionId(0), keywordId(0) {
  }

  virtual ~KeyWords() throw();
  std::string keywords;
  int32_t solutionId;
  int32_t keywordId;

  _KeyWords__isset __isset;

  void __set_keywords(const std::string& val);

  void __set_solutionId(const int32_t val);

  void __set_keywordId(const int32_t val);

  bool operator == (const KeyWords & rhs) const
  {
    if (!(keywords == rhs.keywords))
      return false;
    if (__isset.solutionId != rhs.__isset.solutionId)
      return false;
    else if (__isset.solutionId && !(solutionId == rhs.solutionId))
      return false;
    if (__isset.keywordId != rhs.__isset.keywordId)
      return false;
    else if (__isset.keywordId && !(keywordId == rhs.keywordId))
      return false;
    return true;
  }
  bool operator != (const KeyWords &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const KeyWords & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const KeyWords& obj);
};

void swap(KeyWords &a, KeyWords &b);

typedef struct _Response__isset {
  _Response__isset() : returnCode(false), message(false) {}
  bool returnCode :1;
  bool message :1;
} _Response__isset;

class Response {
 public:

  static const char* ascii_fingerprint; // = "A7801670116150C65ACA43E6F679BA79";
  static const uint8_t binary_fingerprint[16]; // = {0xA7,0x80,0x16,0x70,0x11,0x61,0x50,0xC6,0x5A,0xCA,0x43,0xE6,0xF6,0x79,0xBA,0x79};

  Response(const Response&);
  Response& operator=(const Response&);
  Response() : returnCode(0), message() {
  }

  virtual ~Response() throw();
  int32_t returnCode;
  std::string message;

  _Response__isset __isset;

  void __set_returnCode(const int32_t val);

  void __set_message(const std::string& val);

  bool operator == (const Response & rhs) const
  {
    if (__isset.returnCode != rhs.__isset.returnCode)
      return false;
    else if (__isset.returnCode && !(returnCode == rhs.returnCode))
      return false;
    if (__isset.message != rhs.__isset.message)
      return false;
    else if (__isset.message && !(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const Response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Response& obj);
};

void swap(Response &a, Response &b);

typedef struct _KeywordCreative__isset {
  _KeywordCreative__isset() : creativeId(false), title(false), content(false) {}
  bool creativeId :1;
  bool title :1;
  bool content :1;
} _KeywordCreative__isset;

class KeywordCreative {
 public:

  static const char* ascii_fingerprint; // = "EA49C8C1262074DF53C913E79A866B9E";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0x49,0xC8,0xC1,0x26,0x20,0x74,0xDF,0x53,0xC9,0x13,0xE7,0x9A,0x86,0x6B,0x9E};

  KeywordCreative(const KeywordCreative&);
  KeywordCreative& operator=(const KeywordCreative&);
  KeywordCreative() : creativeId(0), title(), content() {
  }

  virtual ~KeywordCreative() throw();
  int32_t creativeId;
  std::string title;
  std::string content;

  _KeywordCreative__isset __isset;

  void __set_creativeId(const int32_t val);

  void __set_title(const std::string& val);

  void __set_content(const std::string& val);

  bool operator == (const KeywordCreative & rhs) const
  {
    if (__isset.creativeId != rhs.__isset.creativeId)
      return false;
    else if (__isset.creativeId && !(creativeId == rhs.creativeId))
      return false;
    if (__isset.title != rhs.__isset.title)
      return false;
    else if (__isset.title && !(title == rhs.title))
      return false;
    if (__isset.content != rhs.__isset.content)
      return false;
    else if (__isset.content && !(content == rhs.content))
      return false;
    return true;
  }
  bool operator != (const KeywordCreative &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const KeywordCreative & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const KeywordCreative& obj);
};

void swap(KeywordCreative &a, KeywordCreative &b);

typedef struct _KeywordCreativeFeature__isset {
  _KeywordCreativeFeature__isset() : featureName(false) {}
  bool featureName :1;
} _KeywordCreativeFeature__isset;

class KeywordCreativeFeature {
 public:

  static const char* ascii_fingerprint; // = "B1A3984BF7F74C1706A525A526B7E1B2";
  static const uint8_t binary_fingerprint[16]; // = {0xB1,0xA3,0x98,0x4B,0xF7,0xF7,0x4C,0x17,0x06,0xA5,0x25,0xA5,0x26,0xB7,0xE1,0xB2};

  KeywordCreativeFeature(const KeywordCreativeFeature&);
  KeywordCreativeFeature& operator=(const KeywordCreativeFeature&);
  KeywordCreativeFeature() : kcfId(0), featureName() {
  }

  virtual ~KeywordCreativeFeature() throw();
  int64_t kcfId;
  std::string featureName;

  _KeywordCreativeFeature__isset __isset;

  void __set_kcfId(const int64_t val);

  void __set_featureName(const std::string& val);

  bool operator == (const KeywordCreativeFeature & rhs) const
  {
    if (!(kcfId == rhs.kcfId))
      return false;
    if (__isset.featureName != rhs.__isset.featureName)
      return false;
    else if (__isset.featureName && !(featureName == rhs.featureName))
      return false;
    return true;
  }
  bool operator != (const KeywordCreativeFeature &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const KeywordCreativeFeature & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const KeywordCreativeFeature& obj);
};

void swap(KeywordCreativeFeature &a, KeywordCreativeFeature &b);

typedef struct _KeywordCreativeResponse__isset {
  _KeywordCreativeResponse__isset() : creativeId(false), features(false) {}
  bool creativeId :1;
  bool features :1;
} _KeywordCreativeResponse__isset;

class KeywordCreativeResponse {
 public:

  static const char* ascii_fingerprint; // = "64B93FA02E84A97C6E8638608E9DEF2D";
  static const uint8_t binary_fingerprint[16]; // = {0x64,0xB9,0x3F,0xA0,0x2E,0x84,0xA9,0x7C,0x6E,0x86,0x38,0x60,0x8E,0x9D,0xEF,0x2D};

  KeywordCreativeResponse(const KeywordCreativeResponse&);
  KeywordCreativeResponse& operator=(const KeywordCreativeResponse&);
  KeywordCreativeResponse() : creativeId(0) {
  }

  virtual ~KeywordCreativeResponse() throw();
  int32_t creativeId;
  std::vector<KeywordCreativeFeature>  features;

  _KeywordCreativeResponse__isset __isset;

  void __set_creativeId(const int32_t val);

  void __set_features(const std::vector<KeywordCreativeFeature> & val);

  bool operator == (const KeywordCreativeResponse & rhs) const
  {
    if (__isset.creativeId != rhs.__isset.creativeId)
      return false;
    else if (__isset.creativeId && !(creativeId == rhs.creativeId))
      return false;
    if (__isset.features != rhs.__isset.features)
      return false;
    else if (__isset.features && !(features == rhs.features))
      return false;
    return true;
  }
  bool operator != (const KeywordCreativeResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const KeywordCreativeResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const KeywordCreativeResponse& obj);
};

void swap(KeywordCreativeResponse &a, KeywordCreativeResponse &b);

}}} // namespace

#endif

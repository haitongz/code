/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "query_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace com { namespace mediav { namespace query {

int _kPeerStatusValues[] = {
  PeerStatus::P_READY,
  PeerStatus::P_STOP,
  PeerStatus::P_PAUSE,
  PeerStatus::P_DEL
};
const char* _kPeerStatusNames[] = {
  "P_READY",
  "P_STOP",
  "P_PAUSE",
  "P_DEL"
};
const std::map<int, const char*> _PeerStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kPeerStatusValues, _kPeerStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


QueryInfo::~QueryInfo() throw() {
}


void QueryInfo::__set_tokens(const std::vector<std::string> & val) {
  this->tokens = val;
}

void QueryInfo::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void QueryInfo::__set_source(const int32_t val) {
  this->source = val;
__isset.source = true;
}

const char* QueryInfo::ascii_fingerprint = "D97FA59F95051FA1EC8B096DE2508323";
const uint8_t QueryInfo::binary_fingerprint[16] = {0xD9,0x7F,0xA5,0x9F,0x95,0x05,0x1F,0xA1,0xEC,0x8B,0x09,0x6D,0xE2,0x50,0x83,0x23};

uint32_t QueryInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tokens = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tokens.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->tokens.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readString(this->tokens[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          isset_tokens = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->source);
          this->__isset.source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tokens)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t QueryInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("QueryInfo");

  xfer += oprot->writeFieldBegin("tokens", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tokens.size()));
    std::vector<std::string> ::const_iterator _iter5;
    for (_iter5 = this->tokens.begin(); _iter5 != this->tokens.end(); ++_iter5)
    {
      xfer += oprot->writeString((*_iter5));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.source) {
    xfer += oprot->writeFieldBegin("source", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->source);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(QueryInfo &a, QueryInfo &b) {
  using ::std::swap;
  swap(a.tokens, b.tokens);
  swap(a.timestamp, b.timestamp);
  swap(a.source, b.source);
  swap(a.__isset, b.__isset);
}

QueryInfo::QueryInfo(const QueryInfo& other6) {
  tokens = other6.tokens;
  timestamp = other6.timestamp;
  source = other6.source;
  __isset = other6.__isset;
}
QueryInfo& QueryInfo::operator=(const QueryInfo& other7) {
  tokens = other7.tokens;
  timestamp = other7.timestamp;
  source = other7.source;
  __isset = other7.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const QueryInfo& obj) {
  using apache::thrift::to_string;
  out << "QueryInfo(";
  out << "tokens=" << to_string(obj.tokens);
  out << ", " << "timestamp="; (obj.__isset.timestamp ? (out << to_string(obj.timestamp)) : (out << "<null>"));
  out << ", " << "source="; (obj.__isset.source ? (out << to_string(obj.source)) : (out << "<null>"));
  out << ")";
  return out;
}


UrlInfo::~UrlInfo() throw() {
}


void UrlInfo::__set_url(const std::string& val) {
  this->url = val;
}

void UrlInfo::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

const char* UrlInfo::ascii_fingerprint = "E17E126D15049701494262EE3246F603";
const uint8_t UrlInfo::binary_fingerprint[16] = {0xE1,0x7E,0x12,0x6D,0x15,0x04,0x97,0x01,0x49,0x42,0x62,0xEE,0x32,0x46,0xF6,0x03};

uint32_t UrlInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_url = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          isset_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_url)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UrlInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("UrlInfo");

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(UrlInfo &a, UrlInfo &b) {
  using ::std::swap;
  swap(a.url, b.url);
  swap(a.timestamp, b.timestamp);
  swap(a.__isset, b.__isset);
}

UrlInfo::UrlInfo(const UrlInfo& other8) {
  url = other8.url;
  timestamp = other8.timestamp;
  __isset = other8.__isset;
}
UrlInfo& UrlInfo::operator=(const UrlInfo& other9) {
  url = other9.url;
  timestamp = other9.timestamp;
  __isset = other9.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const UrlInfo& obj) {
  using apache::thrift::to_string;
  out << "UrlInfo(";
  out << "url=" << to_string(obj.url);
  out << ", " << "timestamp="; (obj.__isset.timestamp ? (out << to_string(obj.timestamp)) : (out << "<null>"));
  out << ")";
  return out;
}


ProductInfo::~ProductInfo() throw() {
}


void ProductInfo::__set_id(const std::string& val) {
  this->id = val;
}

void ProductInfo::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

const char* ProductInfo::ascii_fingerprint = "E17E126D15049701494262EE3246F603";
const uint8_t ProductInfo::binary_fingerprint[16] = {0xE1,0x7E,0x12,0x6D,0x15,0x04,0x97,0x01,0x49,0x42,0x62,0xEE,0x32,0x46,0xF6,0x03};

uint32_t ProductInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ProductInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ProductInfo");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ProductInfo &a, ProductInfo &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.timestamp, b.timestamp);
  swap(a.__isset, b.__isset);
}

ProductInfo::ProductInfo(const ProductInfo& other10) {
  id = other10.id;
  timestamp = other10.timestamp;
  __isset = other10.__isset;
}
ProductInfo& ProductInfo::operator=(const ProductInfo& other11) {
  id = other11.id;
  timestamp = other11.timestamp;
  __isset = other11.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ProductInfo& obj) {
  using apache::thrift::to_string;
  out << "ProductInfo(";
  out << "id=" << to_string(obj.id);
  out << ", " << "timestamp="; (obj.__isset.timestamp ? (out << to_string(obj.timestamp)) : (out << "<null>"));
  out << ")";
  return out;
}


SiteProductInfo::~SiteProductInfo() throw() {
}


void SiteProductInfo::__set_productInfos(const std::vector<ProductInfo> & val) {
  this->productInfos = val;
}

void SiteProductInfo::__set_src(const std::string& val) {
  this->src = val;
__isset.src = true;
}

const char* SiteProductInfo::ascii_fingerprint = "5EEEC779DFDAE0CCCE7901771348BFB8";
const uint8_t SiteProductInfo::binary_fingerprint[16] = {0x5E,0xEE,0xC7,0x79,0xDF,0xDA,0xE0,0xCC,0xCE,0x79,0x01,0x77,0x13,0x48,0xBF,0xB8};

uint32_t SiteProductInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_productInfos = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->productInfos.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->productInfos.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += this->productInfos[_i16].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_productInfos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->src);
          this->__isset.src = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_productInfos)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SiteProductInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("SiteProductInfo");

  xfer += oprot->writeFieldBegin("productInfos", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->productInfos.size()));
    std::vector<ProductInfo> ::const_iterator _iter17;
    for (_iter17 = this->productInfos.begin(); _iter17 != this->productInfos.end(); ++_iter17)
    {
      xfer += (*_iter17).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.src) {
    xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->src);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(SiteProductInfo &a, SiteProductInfo &b) {
  using ::std::swap;
  swap(a.productInfos, b.productInfos);
  swap(a.src, b.src);
  swap(a.__isset, b.__isset);
}

SiteProductInfo::SiteProductInfo(const SiteProductInfo& other18) {
  productInfos = other18.productInfos;
  src = other18.src;
  __isset = other18.__isset;
}
SiteProductInfo& SiteProductInfo::operator=(const SiteProductInfo& other19) {
  productInfos = other19.productInfos;
  src = other19.src;
  __isset = other19.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const SiteProductInfo& obj) {
  using apache::thrift::to_string;
  out << "SiteProductInfo(";
  out << "productInfos=" << to_string(obj.productInfos);
  out << ", " << "src="; (obj.__isset.src ? (out << to_string(obj.src)) : (out << "<null>"));
  out << ")";
  return out;
}


UserQuery::~UserQuery() throw() {
}


void UserQuery::__set_queries(const std::vector<QueryInfo> & val) {
  this->queries = val;
}

void UserQuery::__set_uid(const std::string& val) {
  this->uid = val;
__isset.uid = true;
}

void UserQuery::__set_lastUpdateTime(const int64_t val) {
  this->lastUpdateTime = val;
__isset.lastUpdateTime = true;
}

void UserQuery::__set_urls(const std::vector<UrlInfo> & val) {
  this->urls = val;
__isset.urls = true;
}

void UserQuery::__set_products(const std::vector<SiteProductInfo> & val) {
  this->products = val;
__isset.products = true;
}

void UserQuery::__set_latestDateData(const bool val) {
  this->latestDateData = val;
__isset.latestDateData = true;
}

void UserQuery::__set_firstMvidData(const bool val) {
  this->firstMvidData = val;
__isset.firstMvidData = true;
}

void UserQuery::__set_mid(const std::string& val) {
  this->mid = val;
__isset.mid = true;
}

const char* UserQuery::ascii_fingerprint = "765DDE17DDF32975722F3601D832E9A6";
const uint8_t UserQuery::binary_fingerprint[16] = {0x76,0x5D,0xDE,0x17,0xDD,0xF3,0x29,0x75,0x72,0x2F,0x36,0x01,0xD8,0x32,0xE9,0xA6};

uint32_t UserQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_queries = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->queries.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->queries.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += this->queries[_i24].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_queries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastUpdateTime);
          this->__isset.lastUpdateTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->urls.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _etype28;
            xfer += iprot->readListBegin(_etype28, _size25);
            this->urls.resize(_size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              xfer += this->urls[_i29].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.urls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->products.clear();
            uint32_t _size30;
            ::apache::thrift::protocol::TType _etype33;
            xfer += iprot->readListBegin(_etype33, _size30);
            this->products.resize(_size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              xfer += this->products[_i34].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.products = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->latestDateData);
          this->__isset.latestDateData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->firstMvidData);
          this->__isset.firstMvidData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mid);
          this->__isset.mid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_queries)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UserQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("UserQuery");

  xfer += oprot->writeFieldBegin("queries", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->queries.size()));
    std::vector<QueryInfo> ::const_iterator _iter35;
    for (_iter35 = this->queries.begin(); _iter35 != this->queries.end(); ++_iter35)
    {
      xfer += (*_iter35).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.uid) {
    xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->uid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastUpdateTime) {
    xfer += oprot->writeFieldBegin("lastUpdateTime", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->lastUpdateTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.urls) {
    xfer += oprot->writeFieldBegin("urls", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->urls.size()));
      std::vector<UrlInfo> ::const_iterator _iter36;
      for (_iter36 = this->urls.begin(); _iter36 != this->urls.end(); ++_iter36)
      {
        xfer += (*_iter36).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.products) {
    xfer += oprot->writeFieldBegin("products", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->products.size()));
      std::vector<SiteProductInfo> ::const_iterator _iter37;
      for (_iter37 = this->products.begin(); _iter37 != this->products.end(); ++_iter37)
      {
        xfer += (*_iter37).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.latestDateData) {
    xfer += oprot->writeFieldBegin("latestDateData", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->latestDateData);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.firstMvidData) {
    xfer += oprot->writeFieldBegin("firstMvidData", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->firstMvidData);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mid) {
    xfer += oprot->writeFieldBegin("mid", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->mid);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(UserQuery &a, UserQuery &b) {
  using ::std::swap;
  swap(a.queries, b.queries);
  swap(a.uid, b.uid);
  swap(a.lastUpdateTime, b.lastUpdateTime);
  swap(a.urls, b.urls);
  swap(a.products, b.products);
  swap(a.latestDateData, b.latestDateData);
  swap(a.firstMvidData, b.firstMvidData);
  swap(a.mid, b.mid);
  swap(a.__isset, b.__isset);
}

UserQuery::UserQuery(const UserQuery& other38) {
  queries = other38.queries;
  uid = other38.uid;
  lastUpdateTime = other38.lastUpdateTime;
  urls = other38.urls;
  products = other38.products;
  latestDateData = other38.latestDateData;
  firstMvidData = other38.firstMvidData;
  mid = other38.mid;
  __isset = other38.__isset;
}
UserQuery& UserQuery::operator=(const UserQuery& other39) {
  queries = other39.queries;
  uid = other39.uid;
  lastUpdateTime = other39.lastUpdateTime;
  urls = other39.urls;
  products = other39.products;
  latestDateData = other39.latestDateData;
  firstMvidData = other39.firstMvidData;
  mid = other39.mid;
  __isset = other39.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const UserQuery& obj) {
  using apache::thrift::to_string;
  out << "UserQuery(";
  out << "queries=" << to_string(obj.queries);
  out << ", " << "uid="; (obj.__isset.uid ? (out << to_string(obj.uid)) : (out << "<null>"));
  out << ", " << "lastUpdateTime="; (obj.__isset.lastUpdateTime ? (out << to_string(obj.lastUpdateTime)) : (out << "<null>"));
  out << ", " << "urls="; (obj.__isset.urls ? (out << to_string(obj.urls)) : (out << "<null>"));
  out << ", " << "products="; (obj.__isset.products ? (out << to_string(obj.products)) : (out << "<null>"));
  out << ", " << "latestDateData="; (obj.__isset.latestDateData ? (out << to_string(obj.latestDateData)) : (out << "<null>"));
  out << ", " << "firstMvidData="; (obj.__isset.firstMvidData ? (out << to_string(obj.firstMvidData)) : (out << "<null>"));
  out << ", " << "mid="; (obj.__isset.mid ? (out << to_string(obj.mid)) : (out << "<null>"));
  out << ")";
  return out;
}


TokenInfo::~TokenInfo() throw() {
}


void TokenInfo::__set_id(const int64_t val) {
  this->id = val;
}

void TokenInfo::__set_weight(const int32_t val) {
  this->weight = val;
__isset.weight = true;
}

const char* TokenInfo::ascii_fingerprint = "6E578DA8AB10EED824A75534350EBAEF";
const uint8_t TokenInfo::binary_fingerprint[16] = {0x6E,0x57,0x8D,0xA8,0xAB,0x10,0xEE,0xD8,0x24,0xA7,0x55,0x34,0x35,0x0E,0xBA,0xEF};

uint32_t TokenInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->weight);
          this->__isset.weight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TokenInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TokenInfo");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.weight) {
    xfer += oprot->writeFieldBegin("weight", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->weight);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TokenInfo &a, TokenInfo &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.weight, b.weight);
  swap(a.__isset, b.__isset);
}

TokenInfo::TokenInfo(const TokenInfo& other40) {
  id = other40.id;
  weight = other40.weight;
  __isset = other40.__isset;
}
TokenInfo& TokenInfo::operator=(const TokenInfo& other41) {
  id = other41.id;
  weight = other41.weight;
  __isset = other41.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TokenInfo& obj) {
  using apache::thrift::to_string;
  out << "TokenInfo(";
  out << "id=" << to_string(obj.id);
  out << ", " << "weight="; (obj.__isset.weight ? (out << to_string(obj.weight)) : (out << "<null>"));
  out << ")";
  return out;
}


QuerySession::~QuerySession() throw() {
}


void QuerySession::__set_tokenInfos(const std::vector<TokenInfo> & val) {
  this->tokenInfos = val;
__isset.tokenInfos = true;
}

void QuerySession::__set_score(const int32_t val) {
  this->score = val;
__isset.score = true;
}

void QuerySession::__set_sessionId(const int64_t val) {
  this->sessionId = val;
__isset.sessionId = true;
}

void QuerySession::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void QuerySession::__set_source(const int32_t val) {
  this->source = val;
__isset.source = true;
}

const char* QuerySession::ascii_fingerprint = "FEA06D03C7B7A4106B656F25D081AC90";
const uint8_t QuerySession::binary_fingerprint[16] = {0xFE,0xA0,0x6D,0x03,0xC7,0xB7,0xA4,0x10,0x6B,0x65,0x6F,0x25,0xD0,0x81,0xAC,0x90};

uint32_t QuerySession::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tokenInfos.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _etype45;
            xfer += iprot->readListBegin(_etype45, _size42);
            this->tokenInfos.resize(_size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              xfer += this->tokenInfos[_i46].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tokenInfos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->score);
          this->__isset.score = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          this->__isset.sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->source);
          this->__isset.source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t QuerySession::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("QuerySession");

  if (this->__isset.tokenInfos) {
    xfer += oprot->writeFieldBegin("tokenInfos", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tokenInfos.size()));
      std::vector<TokenInfo> ::const_iterator _iter47;
      for (_iter47 = this->tokenInfos.begin(); _iter47 != this->tokenInfos.end(); ++_iter47)
      {
        xfer += (*_iter47).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.score) {
    xfer += oprot->writeFieldBegin("score", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->score);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sessionId) {
    xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->sessionId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.source) {
    xfer += oprot->writeFieldBegin("source", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->source);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(QuerySession &a, QuerySession &b) {
  using ::std::swap;
  swap(a.tokenInfos, b.tokenInfos);
  swap(a.score, b.score);
  swap(a.sessionId, b.sessionId);
  swap(a.timestamp, b.timestamp);
  swap(a.source, b.source);
  swap(a.__isset, b.__isset);
}

QuerySession::QuerySession(const QuerySession& other48) {
  tokenInfos = other48.tokenInfos;
  score = other48.score;
  sessionId = other48.sessionId;
  timestamp = other48.timestamp;
  source = other48.source;
  __isset = other48.__isset;
}
QuerySession& QuerySession::operator=(const QuerySession& other49) {
  tokenInfos = other49.tokenInfos;
  score = other49.score;
  sessionId = other49.sessionId;
  timestamp = other49.timestamp;
  source = other49.source;
  __isset = other49.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const QuerySession& obj) {
  using apache::thrift::to_string;
  out << "QuerySession(";
  out << "tokenInfos="; (obj.__isset.tokenInfos ? (out << to_string(obj.tokenInfos)) : (out << "<null>"));
  out << ", " << "score="; (obj.__isset.score ? (out << to_string(obj.score)) : (out << "<null>"));
  out << ", " << "sessionId="; (obj.__isset.sessionId ? (out << to_string(obj.sessionId)) : (out << "<null>"));
  out << ", " << "timestamp="; (obj.__isset.timestamp ? (out << to_string(obj.timestamp)) : (out << "<null>"));
  out << ", " << "source="; (obj.__isset.source ? (out << to_string(obj.source)) : (out << "<null>"));
  out << ")";
  return out;
}


UserInfo::~UserInfo() throw() {
}


void UserInfo::__set_querySessions(const std::vector<QuerySession> & val) {
  this->querySessions = val;
}

void UserInfo::__set_mvid(const std::string& val) {
  this->mvid = val;
__isset.mvid = true;
}

void UserInfo::__set_lastUpdateTime(const int64_t val) {
  this->lastUpdateTime = val;
__isset.lastUpdateTime = true;
}

void UserInfo::__set_experimentId(const int32_t val) {
  this->experimentId = val;
__isset.experimentId = true;
}

void UserInfo::__set_searchLabels(const SearchLabels& val) {
  this->searchLabels = val;
__isset.searchLabels = true;
}

const char* UserInfo::ascii_fingerprint = "AA532CB1EC1C314FFF129A255FF3288C";
const uint8_t UserInfo::binary_fingerprint[16] = {0xAA,0x53,0x2C,0xB1,0xEC,0x1C,0x31,0x4F,0xFF,0x12,0x9A,0x25,0x5F,0xF3,0x28,0x8C};

uint32_t UserInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_querySessions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->querySessions.clear();
            uint32_t _size50;
            ::apache::thrift::protocol::TType _etype53;
            xfer += iprot->readListBegin(_etype53, _size50);
            this->querySessions.resize(_size50);
            uint32_t _i54;
            for (_i54 = 0; _i54 < _size50; ++_i54)
            {
              xfer += this->querySessions[_i54].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_querySessions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mvid);
          this->__isset.mvid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastUpdateTime);
          this->__isset.lastUpdateTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->experimentId);
          this->__isset.experimentId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->searchLabels.read(iprot);
          this->__isset.searchLabels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_querySessions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UserInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("UserInfo");

  xfer += oprot->writeFieldBegin("querySessions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->querySessions.size()));
    std::vector<QuerySession> ::const_iterator _iter55;
    for (_iter55 = this->querySessions.begin(); _iter55 != this->querySessions.end(); ++_iter55)
    {
      xfer += (*_iter55).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.mvid) {
    xfer += oprot->writeFieldBegin("mvid", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->mvid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastUpdateTime) {
    xfer += oprot->writeFieldBegin("lastUpdateTime", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->lastUpdateTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.experimentId) {
    xfer += oprot->writeFieldBegin("experimentId", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->experimentId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.searchLabels) {
    xfer += oprot->writeFieldBegin("searchLabels", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->searchLabels.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(UserInfo &a, UserInfo &b) {
  using ::std::swap;
  swap(a.querySessions, b.querySessions);
  swap(a.mvid, b.mvid);
  swap(a.lastUpdateTime, b.lastUpdateTime);
  swap(a.experimentId, b.experimentId);
  swap(a.searchLabels, b.searchLabels);
  swap(a.__isset, b.__isset);
}

UserInfo::UserInfo(const UserInfo& other56) {
  querySessions = other56.querySessions;
  mvid = other56.mvid;
  lastUpdateTime = other56.lastUpdateTime;
  experimentId = other56.experimentId;
  searchLabels = other56.searchLabels;
  __isset = other56.__isset;
}
UserInfo& UserInfo::operator=(const UserInfo& other57) {
  querySessions = other57.querySessions;
  mvid = other57.mvid;
  lastUpdateTime = other57.lastUpdateTime;
  experimentId = other57.experimentId;
  searchLabels = other57.searchLabels;
  __isset = other57.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const UserInfo& obj) {
  using apache::thrift::to_string;
  out << "UserInfo(";
  out << "querySessions=" << to_string(obj.querySessions);
  out << ", " << "mvid="; (obj.__isset.mvid ? (out << to_string(obj.mvid)) : (out << "<null>"));
  out << ", " << "lastUpdateTime="; (obj.__isset.lastUpdateTime ? (out << to_string(obj.lastUpdateTime)) : (out << "<null>"));
  out << ", " << "experimentId="; (obj.__isset.experimentId ? (out << to_string(obj.experimentId)) : (out << "<null>"));
  out << ", " << "searchLabels="; (obj.__isset.searchLabels ? (out << to_string(obj.searchLabels)) : (out << "<null>"));
  out << ")";
  return out;
}


KeywordLabelInfo::~KeywordLabelInfo() throw() {
}


void KeywordLabelInfo::__set_keywordId(const int64_t val) {
  this->keywordId = val;
}

void KeywordLabelInfo::__set_solutionId(const int32_t val) {
  this->solutionId = val;
}

void KeywordLabelInfo::__set_lastUpdateTime(const int64_t val) {
  this->lastUpdateTime = val;
__isset.lastUpdateTime = true;
}

void KeywordLabelInfo::__set_searchLabels(const std::vector<SearchLabel> & val) {
  this->searchLabels = val;
__isset.searchLabels = true;
}

const char* KeywordLabelInfo::ascii_fingerprint = "364E1D1B76C40346779497AD2B4335BE";
const uint8_t KeywordLabelInfo::binary_fingerprint[16] = {0x36,0x4E,0x1D,0x1B,0x76,0xC4,0x03,0x46,0x77,0x94,0x97,0xAD,0x2B,0x43,0x35,0xBE};

uint32_t KeywordLabelInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_keywordId = false;
  bool isset_solutionId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->keywordId);
          isset_keywordId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->solutionId);
          isset_solutionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastUpdateTime);
          this->__isset.lastUpdateTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->searchLabels.clear();
            uint32_t _size58;
            ::apache::thrift::protocol::TType _etype61;
            xfer += iprot->readListBegin(_etype61, _size58);
            this->searchLabels.resize(_size58);
            uint32_t _i62;
            for (_i62 = 0; _i62 < _size58; ++_i62)
            {
              xfer += this->searchLabels[_i62].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.searchLabels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_keywordId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_solutionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t KeywordLabelInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("KeywordLabelInfo");

  xfer += oprot->writeFieldBegin("keywordId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->keywordId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("solutionId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->solutionId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.lastUpdateTime) {
    xfer += oprot->writeFieldBegin("lastUpdateTime", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->lastUpdateTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.searchLabels) {
    xfer += oprot->writeFieldBegin("searchLabels", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->searchLabels.size()));
      std::vector<SearchLabel> ::const_iterator _iter63;
      for (_iter63 = this->searchLabels.begin(); _iter63 != this->searchLabels.end(); ++_iter63)
      {
        xfer += (*_iter63).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(KeywordLabelInfo &a, KeywordLabelInfo &b) {
  using ::std::swap;
  swap(a.keywordId, b.keywordId);
  swap(a.solutionId, b.solutionId);
  swap(a.lastUpdateTime, b.lastUpdateTime);
  swap(a.searchLabels, b.searchLabels);
  swap(a.__isset, b.__isset);
}

KeywordLabelInfo::KeywordLabelInfo(const KeywordLabelInfo& other64) {
  keywordId = other64.keywordId;
  solutionId = other64.solutionId;
  lastUpdateTime = other64.lastUpdateTime;
  searchLabels = other64.searchLabels;
  __isset = other64.__isset;
}
KeywordLabelInfo& KeywordLabelInfo::operator=(const KeywordLabelInfo& other65) {
  keywordId = other65.keywordId;
  solutionId = other65.solutionId;
  lastUpdateTime = other65.lastUpdateTime;
  searchLabels = other65.searchLabels;
  __isset = other65.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const KeywordLabelInfo& obj) {
  using apache::thrift::to_string;
  out << "KeywordLabelInfo(";
  out << "keywordId=" << to_string(obj.keywordId);
  out << ", " << "solutionId=" << to_string(obj.solutionId);
  out << ", " << "lastUpdateTime="; (obj.__isset.lastUpdateTime ? (out << to_string(obj.lastUpdateTime)) : (out << "<null>"));
  out << ", " << "searchLabels="; (obj.__isset.searchLabels ? (out << to_string(obj.searchLabels)) : (out << "<null>"));
  out << ")";
  return out;
}


KeywordLabelVersionInfo::~KeywordLabelVersionInfo() throw() {
}


void KeywordLabelVersionInfo::__set_version(const int32_t val) {
  this->version = val;
}

void KeywordLabelVersionInfo::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}

void KeywordLabelVersionInfo::__set_maxId(const int64_t val) {
  this->maxId = val;
__isset.maxId = true;
}

const char* KeywordLabelVersionInfo::ascii_fingerprint = "01CA52D1ADEB91222A213253B3603B52";
const uint8_t KeywordLabelVersionInfo::binary_fingerprint[16] = {0x01,0xCA,0x52,0xD1,0xAD,0xEB,0x91,0x22,0x2A,0x21,0x32,0x53,0xB3,0x60,0x3B,0x52};

uint32_t KeywordLabelVersionInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_version = false;
  bool isset_timestamp = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          isset_timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxId);
          this->__isset.maxId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t KeywordLabelVersionInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("KeywordLabelVersionInfo");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.maxId) {
    xfer += oprot->writeFieldBegin("maxId", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->maxId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(KeywordLabelVersionInfo &a, KeywordLabelVersionInfo &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.timestamp, b.timestamp);
  swap(a.maxId, b.maxId);
  swap(a.__isset, b.__isset);
}

KeywordLabelVersionInfo::KeywordLabelVersionInfo(const KeywordLabelVersionInfo& other66) {
  version = other66.version;
  timestamp = other66.timestamp;
  maxId = other66.maxId;
  __isset = other66.__isset;
}
KeywordLabelVersionInfo& KeywordLabelVersionInfo::operator=(const KeywordLabelVersionInfo& other67) {
  version = other67.version;
  timestamp = other67.timestamp;
  maxId = other67.maxId;
  __isset = other67.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const KeywordLabelVersionInfo& obj) {
  using apache::thrift::to_string;
  out << "KeywordLabelVersionInfo(";
  out << "version=" << to_string(obj.version);
  out << ", " << "timestamp=" << to_string(obj.timestamp);
  out << ", " << "maxId="; (obj.__isset.maxId ? (out << to_string(obj.maxId)) : (out << "<null>"));
  out << ")";
  return out;
}


KeywordLabelData::~KeywordLabelData() throw() {
}


void KeywordLabelData::__set_keywordLabelData(const std::map<int64_t, KeywordLabelInfo> & val) {
  this->keywordLabelData = val;
}

const char* KeywordLabelData::ascii_fingerprint = "990061C893714DBCC112E415380E6830";
const uint8_t KeywordLabelData::binary_fingerprint[16] = {0x99,0x00,0x61,0xC8,0x93,0x71,0x4D,0xBC,0xC1,0x12,0xE4,0x15,0x38,0x0E,0x68,0x30};

uint32_t KeywordLabelData::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_keywordLabelData = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->keywordLabelData.clear();
            uint32_t _size68;
            ::apache::thrift::protocol::TType _ktype69;
            ::apache::thrift::protocol::TType _vtype70;
            xfer += iprot->readMapBegin(_ktype69, _vtype70, _size68);
            uint32_t _i72;
            for (_i72 = 0; _i72 < _size68; ++_i72)
            {
              int64_t _key73;
              xfer += iprot->readI64(_key73);
              KeywordLabelInfo& _val74 = this->keywordLabelData[_key73];
              xfer += _val74.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_keywordLabelData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_keywordLabelData)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t KeywordLabelData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("KeywordLabelData");

  xfer += oprot->writeFieldBegin("keywordLabelData", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->keywordLabelData.size()));
    std::map<int64_t, KeywordLabelInfo> ::const_iterator _iter75;
    for (_iter75 = this->keywordLabelData.begin(); _iter75 != this->keywordLabelData.end(); ++_iter75)
    {
      xfer += oprot->writeI64(_iter75->first);
      xfer += _iter75->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(KeywordLabelData &a, KeywordLabelData &b) {
  using ::std::swap;
  swap(a.keywordLabelData, b.keywordLabelData);
}

KeywordLabelData::KeywordLabelData(const KeywordLabelData& other76) {
  keywordLabelData = other76.keywordLabelData;
}
KeywordLabelData& KeywordLabelData::operator=(const KeywordLabelData& other77) {
  keywordLabelData = other77.keywordLabelData;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const KeywordLabelData& obj) {
  using apache::thrift::to_string;
  out << "KeywordLabelData(";
  out << "keywordLabelData=" << to_string(obj.keywordLabelData);
  out << ")";
  return out;
}


ResponseVector::~ResponseVector() throw() {
}


void ResponseVector::__set_tokenInfos(const std::vector<TokenInfo> & val) {
  this->tokenInfos = val;
__isset.tokenInfos = true;
}

void ResponseVector::__set_ktvVersion(const int32_t val) {
  this->ktvVersion = val;
__isset.ktvVersion = true;
}

const char* ResponseVector::ascii_fingerprint = "367BA1B570DF1D1879C584A35E230BD2";
const uint8_t ResponseVector::binary_fingerprint[16] = {0x36,0x7B,0xA1,0xB5,0x70,0xDF,0x1D,0x18,0x79,0xC5,0x84,0xA3,0x5E,0x23,0x0B,0xD2};

uint32_t ResponseVector::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tokenInfos.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            xfer += iprot->readListBegin(_etype81, _size78);
            this->tokenInfos.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += this->tokenInfos[_i82].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tokenInfos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ktvVersion);
          this->__isset.ktvVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ResponseVector::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ResponseVector");

  if (this->__isset.tokenInfos) {
    xfer += oprot->writeFieldBegin("tokenInfos", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tokenInfos.size()));
      std::vector<TokenInfo> ::const_iterator _iter83;
      for (_iter83 = this->tokenInfos.begin(); _iter83 != this->tokenInfos.end(); ++_iter83)
      {
        xfer += (*_iter83).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ktvVersion) {
    xfer += oprot->writeFieldBegin("ktvVersion", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->ktvVersion);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ResponseVector &a, ResponseVector &b) {
  using ::std::swap;
  swap(a.tokenInfos, b.tokenInfos);
  swap(a.ktvVersion, b.ktvVersion);
  swap(a.__isset, b.__isset);
}

ResponseVector::ResponseVector(const ResponseVector& other84) {
  tokenInfos = other84.tokenInfos;
  ktvVersion = other84.ktvVersion;
  __isset = other84.__isset;
}
ResponseVector& ResponseVector::operator=(const ResponseVector& other85) {
  tokenInfos = other85.tokenInfos;
  ktvVersion = other85.ktvVersion;
  __isset = other85.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ResponseVector& obj) {
  using apache::thrift::to_string;
  out << "ResponseVector(";
  out << "tokenInfos="; (obj.__isset.tokenInfos ? (out << to_string(obj.tokenInfos)) : (out << "<null>"));
  out << ", " << "ktvVersion="; (obj.__isset.ktvVersion ? (out << to_string(obj.ktvVersion)) : (out << "<null>"));
  out << ")";
  return out;
}


KeyWords::~KeyWords() throw() {
}


void KeyWords::__set_keywords(const std::string& val) {
  this->keywords = val;
}

void KeyWords::__set_solutionId(const int32_t val) {
  this->solutionId = val;
__isset.solutionId = true;
}

void KeyWords::__set_keywordId(const int32_t val) {
  this->keywordId = val;
__isset.keywordId = true;
}

const char* KeyWords::ascii_fingerprint = "F89B267CDACD3B46B828BD23E9151E7F";
const uint8_t KeyWords::binary_fingerprint[16] = {0xF8,0x9B,0x26,0x7C,0xDA,0xCD,0x3B,0x46,0xB8,0x28,0xBD,0x23,0xE9,0x15,0x1E,0x7F};

uint32_t KeyWords::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_keywords = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->keywords);
          isset_keywords = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->solutionId);
          this->__isset.solutionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->keywordId);
          this->__isset.keywordId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_keywords)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t KeyWords::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("KeyWords");

  xfer += oprot->writeFieldBegin("keywords", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->keywords);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.solutionId) {
    xfer += oprot->writeFieldBegin("solutionId", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->solutionId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.keywordId) {
    xfer += oprot->writeFieldBegin("keywordId", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->keywordId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(KeyWords &a, KeyWords &b) {
  using ::std::swap;
  swap(a.keywords, b.keywords);
  swap(a.solutionId, b.solutionId);
  swap(a.keywordId, b.keywordId);
  swap(a.__isset, b.__isset);
}

KeyWords::KeyWords(const KeyWords& other86) {
  keywords = other86.keywords;
  solutionId = other86.solutionId;
  keywordId = other86.keywordId;
  __isset = other86.__isset;
}
KeyWords& KeyWords::operator=(const KeyWords& other87) {
  keywords = other87.keywords;
  solutionId = other87.solutionId;
  keywordId = other87.keywordId;
  __isset = other87.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const KeyWords& obj) {
  using apache::thrift::to_string;
  out << "KeyWords(";
  out << "keywords=" << to_string(obj.keywords);
  out << ", " << "solutionId="; (obj.__isset.solutionId ? (out << to_string(obj.solutionId)) : (out << "<null>"));
  out << ", " << "keywordId="; (obj.__isset.keywordId ? (out << to_string(obj.keywordId)) : (out << "<null>"));
  out << ")";
  return out;
}


Response::~Response() throw() {
}


void Response::__set_returnCode(const int32_t val) {
  this->returnCode = val;
__isset.returnCode = true;
}

void Response::__set_message(const std::string& val) {
  this->message = val;
__isset.message = true;
}

const char* Response::ascii_fingerprint = "A7801670116150C65ACA43E6F679BA79";
const uint8_t Response::binary_fingerprint[16] = {0xA7,0x80,0x16,0x70,0x11,0x61,0x50,0xC6,0x5A,0xCA,0x43,0xE6,0xF6,0x79,0xBA,0x79};

uint32_t Response::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->returnCode);
          this->__isset.returnCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Response");

  if (this->__isset.returnCode) {
    xfer += oprot->writeFieldBegin("returnCode", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->returnCode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Response &a, Response &b) {
  using ::std::swap;
  swap(a.returnCode, b.returnCode);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

Response::Response(const Response& other88) {
  returnCode = other88.returnCode;
  message = other88.message;
  __isset = other88.__isset;
}
Response& Response::operator=(const Response& other89) {
  returnCode = other89.returnCode;
  message = other89.message;
  __isset = other89.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Response& obj) {
  using apache::thrift::to_string;
  out << "Response(";
  out << "returnCode="; (obj.__isset.returnCode ? (out << to_string(obj.returnCode)) : (out << "<null>"));
  out << ", " << "message="; (obj.__isset.message ? (out << to_string(obj.message)) : (out << "<null>"));
  out << ")";
  return out;
}


KeywordCreative::~KeywordCreative() throw() {
}


void KeywordCreative::__set_creativeId(const int32_t val) {
  this->creativeId = val;
__isset.creativeId = true;
}

void KeywordCreative::__set_title(const std::string& val) {
  this->title = val;
__isset.title = true;
}

void KeywordCreative::__set_content(const std::string& val) {
  this->content = val;
__isset.content = true;
}

const char* KeywordCreative::ascii_fingerprint = "EA49C8C1262074DF53C913E79A866B9E";
const uint8_t KeywordCreative::binary_fingerprint[16] = {0xEA,0x49,0xC8,0xC1,0x26,0x20,0x74,0xDF,0x53,0xC9,0x13,0xE7,0x9A,0x86,0x6B,0x9E};

uint32_t KeywordCreative::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->creativeId);
          this->__isset.creativeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->content);
          this->__isset.content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KeywordCreative::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("KeywordCreative");

  if (this->__isset.creativeId) {
    xfer += oprot->writeFieldBegin("creativeId", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->creativeId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.title) {
    xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->title);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.content) {
    xfer += oprot->writeFieldBegin("content", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->content);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(KeywordCreative &a, KeywordCreative &b) {
  using ::std::swap;
  swap(a.creativeId, b.creativeId);
  swap(a.title, b.title);
  swap(a.content, b.content);
  swap(a.__isset, b.__isset);
}

KeywordCreative::KeywordCreative(const KeywordCreative& other90) {
  creativeId = other90.creativeId;
  title = other90.title;
  content = other90.content;
  __isset = other90.__isset;
}
KeywordCreative& KeywordCreative::operator=(const KeywordCreative& other91) {
  creativeId = other91.creativeId;
  title = other91.title;
  content = other91.content;
  __isset = other91.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const KeywordCreative& obj) {
  using apache::thrift::to_string;
  out << "KeywordCreative(";
  out << "creativeId="; (obj.__isset.creativeId ? (out << to_string(obj.creativeId)) : (out << "<null>"));
  out << ", " << "title="; (obj.__isset.title ? (out << to_string(obj.title)) : (out << "<null>"));
  out << ", " << "content="; (obj.__isset.content ? (out << to_string(obj.content)) : (out << "<null>"));
  out << ")";
  return out;
}


KeywordCreativeFeature::~KeywordCreativeFeature() throw() {
}


void KeywordCreativeFeature::__set_kcfId(const int64_t val) {
  this->kcfId = val;
}

void KeywordCreativeFeature::__set_featureName(const std::string& val) {
  this->featureName = val;
__isset.featureName = true;
}

const char* KeywordCreativeFeature::ascii_fingerprint = "B1A3984BF7F74C1706A525A526B7E1B2";
const uint8_t KeywordCreativeFeature::binary_fingerprint[16] = {0xB1,0xA3,0x98,0x4B,0xF7,0xF7,0x4C,0x17,0x06,0xA5,0x25,0xA5,0x26,0xB7,0xE1,0xB2};

uint32_t KeywordCreativeFeature::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_kcfId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->kcfId);
          isset_kcfId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->featureName);
          this->__isset.featureName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_kcfId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t KeywordCreativeFeature::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("KeywordCreativeFeature");

  xfer += oprot->writeFieldBegin("kcfId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->kcfId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.featureName) {
    xfer += oprot->writeFieldBegin("featureName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->featureName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(KeywordCreativeFeature &a, KeywordCreativeFeature &b) {
  using ::std::swap;
  swap(a.kcfId, b.kcfId);
  swap(a.featureName, b.featureName);
  swap(a.__isset, b.__isset);
}

KeywordCreativeFeature::KeywordCreativeFeature(const KeywordCreativeFeature& other92) {
  kcfId = other92.kcfId;
  featureName = other92.featureName;
  __isset = other92.__isset;
}
KeywordCreativeFeature& KeywordCreativeFeature::operator=(const KeywordCreativeFeature& other93) {
  kcfId = other93.kcfId;
  featureName = other93.featureName;
  __isset = other93.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const KeywordCreativeFeature& obj) {
  using apache::thrift::to_string;
  out << "KeywordCreativeFeature(";
  out << "kcfId=" << to_string(obj.kcfId);
  out << ", " << "featureName="; (obj.__isset.featureName ? (out << to_string(obj.featureName)) : (out << "<null>"));
  out << ")";
  return out;
}


KeywordCreativeResponse::~KeywordCreativeResponse() throw() {
}


void KeywordCreativeResponse::__set_creativeId(const int32_t val) {
  this->creativeId = val;
__isset.creativeId = true;
}

void KeywordCreativeResponse::__set_features(const std::vector<KeywordCreativeFeature> & val) {
  this->features = val;
__isset.features = true;
}

const char* KeywordCreativeResponse::ascii_fingerprint = "64B93FA02E84A97C6E8638608E9DEF2D";
const uint8_t KeywordCreativeResponse::binary_fingerprint[16] = {0x64,0xB9,0x3F,0xA0,0x2E,0x84,0xA9,0x7C,0x6E,0x86,0x38,0x60,0x8E,0x9D,0xEF,0x2D};

uint32_t KeywordCreativeResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->creativeId);
          this->__isset.creativeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->features.clear();
            uint32_t _size94;
            ::apache::thrift::protocol::TType _etype97;
            xfer += iprot->readListBegin(_etype97, _size94);
            this->features.resize(_size94);
            uint32_t _i98;
            for (_i98 = 0; _i98 < _size94; ++_i98)
            {
              xfer += this->features[_i98].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.features = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KeywordCreativeResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("KeywordCreativeResponse");

  if (this->__isset.creativeId) {
    xfer += oprot->writeFieldBegin("creativeId", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->creativeId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.features) {
    xfer += oprot->writeFieldBegin("features", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->features.size()));
      std::vector<KeywordCreativeFeature> ::const_iterator _iter99;
      for (_iter99 = this->features.begin(); _iter99 != this->features.end(); ++_iter99)
      {
        xfer += (*_iter99).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(KeywordCreativeResponse &a, KeywordCreativeResponse &b) {
  using ::std::swap;
  swap(a.creativeId, b.creativeId);
  swap(a.features, b.features);
  swap(a.__isset, b.__isset);
}

KeywordCreativeResponse::KeywordCreativeResponse(const KeywordCreativeResponse& other100) {
  creativeId = other100.creativeId;
  features = other100.features;
  __isset = other100.__isset;
}
KeywordCreativeResponse& KeywordCreativeResponse::operator=(const KeywordCreativeResponse& other101) {
  creativeId = other101.creativeId;
  features = other101.features;
  __isset = other101.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const KeywordCreativeResponse& obj) {
  using apache::thrift::to_string;
  out << "KeywordCreativeResponse(";
  out << "creativeId="; (obj.__isset.creativeId ? (out << to_string(obj.creativeId)) : (out << "<null>"));
  out << ", " << "features="; (obj.__isset.features ? (out << to_string(obj.features)) : (out << "<null>"));
  out << ")";
  return out;
}

}}} // namespace
